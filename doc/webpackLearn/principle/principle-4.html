<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>5-4 编写 Plugin | 深入浅出Webpack</title>
    <meta name="description" content="webpack使用学习(吴浩麟版)">
    <link rel="icon" href="/webpackLearn/favicon.ico">
  <link rel="manifest" href="/webpackLearn/manifest.json">
    
    <link rel="preload" href="/webpackLearn/assets/css/styles.77d280ee.css" as="style"><link rel="preload" href="/webpackLearn/assets/js/app.77d280ee.js" as="script"><link rel="preload" href="/webpackLearn/assets/js/57.82800a68.js" as="script"><link rel="prefetch" href="/webpackLearn/assets/js/1.f37f7214.js"><link rel="prefetch" href="/webpackLearn/assets/js/10.15a163ee.js"><link rel="prefetch" href="/webpackLearn/assets/js/11.d8cde28c.js"><link rel="prefetch" href="/webpackLearn/assets/js/12.6e485d95.js"><link rel="prefetch" href="/webpackLearn/assets/js/13.8167464c.js"><link rel="prefetch" href="/webpackLearn/assets/js/14.7e75c412.js"><link rel="prefetch" href="/webpackLearn/assets/js/15.593f55f2.js"><link rel="prefetch" href="/webpackLearn/assets/js/16.31248cfb.js"><link rel="prefetch" href="/webpackLearn/assets/js/17.c428f9be.js"><link rel="prefetch" href="/webpackLearn/assets/js/18.1a442e25.js"><link rel="prefetch" href="/webpackLearn/assets/js/19.d2aaef13.js"><link rel="prefetch" href="/webpackLearn/assets/js/2.d7cdf3d2.js"><link rel="prefetch" href="/webpackLearn/assets/js/20.d7645fb0.js"><link rel="prefetch" href="/webpackLearn/assets/js/21.d80e0286.js"><link rel="prefetch" href="/webpackLearn/assets/js/22.b41f3cbc.js"><link rel="prefetch" href="/webpackLearn/assets/js/23.f8779f82.js"><link rel="prefetch" href="/webpackLearn/assets/js/24.958d3c85.js"><link rel="prefetch" href="/webpackLearn/assets/js/25.2e076f51.js"><link rel="prefetch" href="/webpackLearn/assets/js/26.eff2c3e5.js"><link rel="prefetch" href="/webpackLearn/assets/js/27.40064e0e.js"><link rel="prefetch" href="/webpackLearn/assets/js/28.9ad06b95.js"><link rel="prefetch" href="/webpackLearn/assets/js/29.3a0865a0.js"><link rel="prefetch" href="/webpackLearn/assets/js/3.128b6292.js"><link rel="prefetch" href="/webpackLearn/assets/js/30.25c4f77e.js"><link rel="prefetch" href="/webpackLearn/assets/js/31.80207808.js"><link rel="prefetch" href="/webpackLearn/assets/js/32.20b8aa68.js"><link rel="prefetch" href="/webpackLearn/assets/js/33.414db07e.js"><link rel="prefetch" href="/webpackLearn/assets/js/34.3c015b40.js"><link rel="prefetch" href="/webpackLearn/assets/js/35.cfff3ee7.js"><link rel="prefetch" href="/webpackLearn/assets/js/36.5693324e.js"><link rel="prefetch" href="/webpackLearn/assets/js/37.11302d4c.js"><link rel="prefetch" href="/webpackLearn/assets/js/38.5f09cd6d.js"><link rel="prefetch" href="/webpackLearn/assets/js/39.b8a318d2.js"><link rel="prefetch" href="/webpackLearn/assets/js/4.7fbde3f9.js"><link rel="prefetch" href="/webpackLearn/assets/js/40.010eca0d.js"><link rel="prefetch" href="/webpackLearn/assets/js/41.ed550296.js"><link rel="prefetch" href="/webpackLearn/assets/js/42.bf111eba.js"><link rel="prefetch" href="/webpackLearn/assets/js/43.4178a489.js"><link rel="prefetch" href="/webpackLearn/assets/js/44.f9b7d3d8.js"><link rel="prefetch" href="/webpackLearn/assets/js/45.4aa3e07a.js"><link rel="prefetch" href="/webpackLearn/assets/js/46.766fddaf.js"><link rel="prefetch" href="/webpackLearn/assets/js/47.7a16de60.js"><link rel="prefetch" href="/webpackLearn/assets/js/48.ec0b2eb5.js"><link rel="prefetch" href="/webpackLearn/assets/js/49.9ba3c919.js"><link rel="prefetch" href="/webpackLearn/assets/js/5.7aab97c6.js"><link rel="prefetch" href="/webpackLearn/assets/js/50.fe7bdfef.js"><link rel="prefetch" href="/webpackLearn/assets/js/51.b5d4459d.js"><link rel="prefetch" href="/webpackLearn/assets/js/52.aa5814ff.js"><link rel="prefetch" href="/webpackLearn/assets/js/53.8ad00778.js"><link rel="prefetch" href="/webpackLearn/assets/js/54.92f9cbd1.js"><link rel="prefetch" href="/webpackLearn/assets/js/55.d04ea61a.js"><link rel="prefetch" href="/webpackLearn/assets/js/56.4b17dc92.js"><link rel="prefetch" href="/webpackLearn/assets/js/58.b4482327.js"><link rel="prefetch" href="/webpackLearn/assets/js/59.40bf3560.js"><link rel="prefetch" href="/webpackLearn/assets/js/6.e891bd55.js"><link rel="prefetch" href="/webpackLearn/assets/js/60.3a147a38.js"><link rel="prefetch" href="/webpackLearn/assets/js/61.9fab59f3.js"><link rel="prefetch" href="/webpackLearn/assets/js/62.7aacd083.js"><link rel="prefetch" href="/webpackLearn/assets/js/63.7e09e4d8.js"><link rel="prefetch" href="/webpackLearn/assets/js/64.b3113e47.js"><link rel="prefetch" href="/webpackLearn/assets/js/65.d1030852.js"><link rel="prefetch" href="/webpackLearn/assets/js/66.799e920a.js"><link rel="prefetch" href="/webpackLearn/assets/js/67.a898b698.js"><link rel="prefetch" href="/webpackLearn/assets/js/68.92cd43e9.js"><link rel="prefetch" href="/webpackLearn/assets/js/69.262008ea.js"><link rel="prefetch" href="/webpackLearn/assets/js/7.22611dc1.js"><link rel="prefetch" href="/webpackLearn/assets/js/70.afff8df7.js"><link rel="prefetch" href="/webpackLearn/assets/js/71.7818a2c2.js"><link rel="prefetch" href="/webpackLearn/assets/js/8.5b18428a.js"><link rel="prefetch" href="/webpackLearn/assets/js/9.9ef066a0.js">
    <link rel="stylesheet" href="/webpackLearn/assets/css/styles.77d280ee.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/webpackLearn/" class="home-link router-link-active"><!----><span class="site-name">
      深入浅出Webpack
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/webpackLearn/" class="nav-link">首页</a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/webpackLearn/" class="nav-link">首页</a></div><!----></nav><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading"><span>入门</span><!----></p><ul class="sidebar-group-items"><li><a href="/webpackLearn/intro.html" class="sidebar-link">前言</a></li><li><a href="/webpackLearn/intro/intro-1.html" class="sidebar-link">前端的发展</a></li><li><a href="/webpackLearn/intro/intro-2.html" class="sidebar-link">前端常用构建工具</a></li><li><a href="/webpackLearn/intro/intro-3.html" class="sidebar-link">webpack安装使用</a></li><li><a href="/webpackLearn/intro/intro-4.html" class="sidebar-link">使用Loader</a></li><li><a href="/webpackLearn/intro/intro-5.html" class="sidebar-link">使用Plugin</a></li><li><a href="/webpackLearn/intro/intro-6.html" class="sidebar-link">使用DevServer</a></li><li><a href="/webpackLearn/intro/intro-7.html" class="sidebar-link">核心概念</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>配置</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>实战</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>优化</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>原理</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/webpackLearn/principle/principle-1.html" class="sidebar-link">工作原理概括</a></li><li><a href="/webpackLearn/principle/principle-2.html" class="sidebar-link">输出文件分析</a></li><li><a href="/webpackLearn/principle/principle-3.html" class="sidebar-link">编写Loader</a></li><li><a href="/webpackLearn/principle/principle-4.html" class="active sidebar-link">编写Plugin</a></li><li><a href="/webpackLearn/principle/principle-5.html" class="sidebar-link">调试Webpack</a></li><li><a href="/webpackLearn/principle/principle-6.html" class="sidebar-link">原理总结</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>附录</span><span class="arrow right"></span></p><!----></div></li></ul></div><div class="page"><div class="content"><h1 id="_5-4-编写-plugin"><a href="#_5-4-编写-plugin" aria-hidden="true" class="header-anchor">#</a> 5-4 编写 Plugin</h1><p>Webpack 通过 Plugin 机制让其更加灵活，以适应各种应用场景。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><p>一个最基础的 Plugin 的代码是这样的：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">BasicPlugin</span> <span class="token punctuation">{</span>
  <span class="token comment">// 在构造函数中获取用户给该插件传入的配置</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">&quot;compilation&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">compilation</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 导出 Plugin</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> BasicPlugin<span class="token punctuation">;</span>
</code></pre></div><p>在使用这个 Plugin 时，相关配置代码如下：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> BasicPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./BasicPlugin.js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
module<span class="token punctuation">.</span>export <span class="token operator">=</span> <span class="token punctuation">{</span>
  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">BasicPlugin</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>过程：</p><ul><li>webpack 启动后，在读取配置的过程中会先执行 <code>new BasicPlugin(options)</code> 初始化一个 <code>BasicPlugin</code> 获得其实例。</li><li>在初始化 <code>compiler</code> 对象后，再调用 <code>basicPlugin.apply(compiler)</code> 给插件实例传入 <code>compiler</code> 对象。</li><li>插件实例在获取到 <code>compiler</code> 对象后，就可以通过 <code>compiler.plugin(事件名称, 回调函数)</code> 监听到 Webpack 广播出来的事件。 并且可以通过 compiler 对象去操作 Webpack。</li></ul><p>通过以上最简单的 Plugin 相信你大概明白了 Plugin 的工作原理，但实际开发中还有很多细节需要注意，下面来详细介绍。</p><h2 id="compiler-和-compilation"><a href="#compiler-和-compilation" aria-hidden="true" class="header-anchor">#</a> Compiler 和 Compilation</h2><p>在开发 Plugin 时最常用的两个对象就是 Compiler 和 Compilation，它们是 Plugin 和 Webpack 之间的桥梁。 Compiler 和 Compilation 的含义如下：</p><ul><li><p><code>Compiler</code>对象包含了 Webpack 环境所有的的配置信息，包含 <code>options</code>，<code>loaders</code>，<code>plugins</code> 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例；</p></li><li><p><code>Compilation</code>对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展。通过 Compilation 也能读取到 Compiler 对象。</p></li></ul><blockquote><p>Compiler 和 Compilation 的区别在于：Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译。</p></blockquote><h2 id="事件流"><a href="#事件流" aria-hidden="true" class="header-anchor">#</a> 事件流</h2><p>Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的 <strong>每个处理流程的职责都是单一</strong>的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。</p><p>Webpack 通过 <code>Tapable</code> 来组织这条复杂的生产线。 Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 Webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。</p><p>Webpack 的事件流机制应用了观察者模式，和 Node.js 中的 <code>EventEmitter</code> 非常相似。 <code>Compiler</code> 和 <code>Compilation</code> 都继承自 <code>Tapable</code>，可以直接在 <code>Compiler</code> 和 <code>Compilation</code> 对象上广播和监听事件，方法如下：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * 广播出事件
 * event-name 为事件名称，注意不要和现有的事件重名
 * params 为附带的参数
 */</span>
<span class="token function">compiler</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">&quot;event-name&quot;</span><span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。
 * 同时函数中的 params 参数为广播事件时附带的参数。
 */</span>
compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">&quot;event-name&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>同理，<code>compilation.apply</code> 和 <code>compilation.plugin</code> 使用方法和上面一致。</p><p>在开发插件时，你可能会不知道该如何下手，因为你不知道该监听哪个事件才能完成任务。</p><p>在开发插件时，还需要注意以下两点：</p><ul><li>只要能拿到 Compiler 或 Compilation 对象，就能广播出新的事件，所以在新开发的插件中也能广播出事件，给其它插件监听使用。</li><li>传给每个插件的 Compiler 和 Compilation 对象都是同一个引用。也就是说在一个插件中修改了 Compiler 或 Compilation 对象上的属性，会影响到后面的插件。</li></ul><p>有些事件是异步的，这些异步的事件会附带两个参数，第二个参数为回调函数，在插件处理完任务时需要调用回调函数通知 Webpack，才会进入下一处理流程。例如：</p><div class="language-js extra-class"><pre class="language-js"><code>compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">&quot;emit&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">compilation<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 支持处理逻辑</span>

  <span class="token comment">// 处理完毕后执行 callback 以通知 Webpack</span>
  <span class="token comment">// 如果不执行 callback，运行流程将会一直卡在这不往下执行</span>
  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="常用-api"><a href="#常用-api" aria-hidden="true" class="header-anchor">#</a> 常用 API</h2><p>插件可以用来修改输出文件、增加输出文件、甚至可以提升 Webpack 性能、等等，总之插件通过调用 Webpack 提供的 API 能完成很多事情。 由于 Webpack 提供的 API 非常多，有很多 API 很少用的上，又加上篇幅有限，下面来介绍一些常用的 API。</p><h3 id="读取输出资源、代码块、模块及其依赖"><a href="#读取输出资源、代码块、模块及其依赖" aria-hidden="true" class="header-anchor">#</a> 读取输出资源、代码块、模块及其依赖</h3><p>有些插件可能需要读取 Webpack 的处理结果，例如输出资源、代码块、模块及其依赖，以便做下一步处理。</p><p>在 <code>emit</code> 事件发生时，代表源文件的转换和组装已经完成，在这里可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容。 插件代码如下：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Plugin</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">&quot;emit&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">compilation<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// compilation.chunks 存放所有代码块，是一个数组</span>
      compilation<span class="token punctuation">.</span>chunks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// chunk 代表一个代码块</span>
        <span class="token comment">// 代码块由多个模块组成，通过 chunk.forEachModule 能读取组成代码块的每个模块</span>
        chunk<span class="token punctuation">.</span><span class="token function">forEachModule</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// module 代表一个模块</span>
          <span class="token comment">// module.fileDependencies 存放当前模块的所有依赖的文件路径，是一个数组</span>
          module<span class="token punctuation">.</span>fileDependencies<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">filepath</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Webpack 会根据 Chunk 去生成输出的文件资源，每个 Chunk 都对应一个及其以上的输出文件</span>
        <span class="token comment">// 例如在 Chunk 中包含了 CSS 模块并且使用了 ExtractTextPlugin 时，</span>
        <span class="token comment">// 该 Chunk 就会生成 .js 和 .css 两个文件</span>
        chunk<span class="token punctuation">.</span>files<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">filename</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// compilation.assets 存放当前所有即将输出的资源</span>
          <span class="token comment">// 调用一个输出资源的 source() 方法能获取到输出资源的内容</span>
          <span class="token keyword">let</span> source <span class="token operator">=</span> compilation<span class="token punctuation">.</span>assets<span class="token punctuation">[</span>filename<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// 这是一个异步事件，要记得调用 callback 通知 Webpack 本次事件监听处理结束。</span>
      <span class="token comment">// 如果忘记了调用 callback，Webpack 将一直卡在这里而不会往后执行。</span>
      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="监听文件变化"><a href="#监听文件变化" aria-hidden="true" class="header-anchor">#</a> 监听文件变化</h3><p>在<a href="/webpackLearn/optimize/optimize-5.html">使用自动刷新</a> 中介绍过 Webpack 会从配置的入口模块出发，依次找出所有的依赖模块，当入口模块或者其依赖的模块发生变化时， 就会触发一次新的 <code>Compilation</code>。</p><p>在开发插件时经常需要知道是哪个文件发生变化导致了新的 <code>Compilation</code>，为此可以使用如下代码：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 当依赖的文件发生变化时会触发 watch-run 事件</span>
compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">&quot;watch-run&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">watching<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取发生变化的文件列表</span>
  <span class="token keyword">const</span> changedFiles <span class="token operator">=</span> watching<span class="token punctuation">.</span>compiler<span class="token punctuation">.</span>watchFileSystem<span class="token punctuation">.</span>watcher<span class="token punctuation">.</span>mtimes<span class="token punctuation">;</span>
  <span class="token comment">// changedFiles 格式为键值对，键为发生变化的文件路径。</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>changedFiles<span class="token punctuation">[</span>filePath<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// filePath 对应的文件发生了变化</span>
  <span class="token punctuation">}</span>
  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>默认情况下 Webpack 只会监视入口和其依赖的模块是否发生变化，在有些情况下项目可能需要引入新的文件，例如引入一个 HTML 文件。 由于 JavaScript 文件不会去导入 HTML 文件，Webpack 就不会监听 HTML 文件的变化，编辑 HTML 文件时就不会重新触发新的 <code>Compilation</code>。 为了监听 HTML 文件的变化，我们需要把 HTML 文件加入到依赖列表中，为此可以使用如下代码：</p><div class="language-js extra-class"><pre class="language-js"><code>compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">&quot;after-compile&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">compilation<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 把 HTML 文件添加到文件依赖列表，好让 Webpack 去监听 HTML 模块文件，在 HTML 模版文件发生变化时重新启动一次编译</span>
  compilation<span class="token punctuation">.</span>fileDependencies<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="修改输出资源"><a href="#修改输出资源" aria-hidden="true" class="header-anchor">#</a> 修改输出资源</h3><p>有些场景下插件需要修改、增加、删除输出的资源，要做到这点需要监听 <code>emit</code> 事件，因为发生 <code>emit</code> 事件时所有模块的转换和代码块对应的文件已经生成好， 需要输出的资源即将输出，因此 <code>emit</code> 事件是修改 Webpack 输出资源的最后时机。</p><p>所有需要输出的资源会存放在 <code>compilation.assets</code> 中，<code>compilation.assets</code> 是一个键值对，键为需要输出的文件名称，值为文件对应的内容。</p><p>设置 <code>compilation.assets</code> 的代码如下：</p><div class="language-js extra-class"><pre class="language-js"><code>compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">&quot;emit&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">compilation<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 设置名称为 fileName 的输出资源</span>
  compilation<span class="token punctuation">.</span>assets<span class="token punctuation">[</span>fileName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 返回文件内容</span>
    <span class="token function-variable function">source</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// fileContent 既可以是代表文本文件的字符串，也可以是代表二进制文件的 Buffer</span>
      <span class="token keyword">return</span> fileContent<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 返回文件大小</span>
    <span class="token function-variable function">size</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> Buffer<span class="token punctuation">.</span><span class="token function">byteLength</span><span class="token punctuation">(</span>fileContent<span class="token punctuation">,</span> <span class="token string">&quot;utf8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>读取 <code>compilation.assets</code> 的代码如下：</p><div class="language-js extra-class"><pre class="language-js"><code>compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">&quot;emit&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">compilation<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 读取名称为 fileName 的输出资源</span>
  <span class="token keyword">const</span> asset <span class="token operator">=</span> compilation<span class="token punctuation">.</span>assets<span class="token punctuation">[</span>fileName<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 获取输出资源的内容</span>
  asset<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 获取输出资源的文件大小</span>
  asset<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="判断-webpack-使用了哪些插件"><a href="#判断-webpack-使用了哪些插件" aria-hidden="true" class="header-anchor">#</a> 判断 Webpack 使用了哪些插件</h3><p>在开发一个插件时可能需要根据当前配置是否使用了其它某个插件而做下一步决定，因此需要读取 Webpack 当前的插件配置情况。 以判断当前是否使用了 <code>ExtractTextPlugin</code> 为例，可以使用如下代码：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 判断当前配置使用使用了 ExtractTextPlugin，</span>
<span class="token comment">// compiler 参数即为 Webpack 在 apply(compiler) 中传入的参数</span>
<span class="token keyword">function</span> <span class="token function">hasExtractTextPlugin</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当前配置所有使用的插件列表</span>
  <span class="token keyword">const</span> plugins <span class="token operator">=</span> compiler<span class="token punctuation">.</span>options<span class="token punctuation">.</span>plugins<span class="token punctuation">;</span>
  <span class="token comment">// 去 plugins 中寻找有没有 ExtractTextPlugin 的实例</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    plugins<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>
      <span class="token parameter">plugin</span> <span class="token operator">=&gt;</span> plugin<span class="token punctuation">.</span><span class="token class-name">__proto__</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> ExtractTextPlugin
    <span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="实战"><a href="#实战" aria-hidden="true" class="header-anchor">#</a> 实战</h2><p>下面我们举一个实际的例子，带你一步步去实现一个插件。</p><p>该插件的名称取名叫 <code>EndWebpackPlugin</code>，作用是在 Webpack 即将退出时再附加一些额外的操作，例如在 Webpack 成功编译和输出了文件后执行发布操作把输出的文件上传到服务器。 同时该插件还能区分 Webpack 构建是否执行成功。使用该插件时方法如下：</p><div class="language-js extra-class"><pre class="language-js"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// 在初始化 EndWebpackPlugin 时传入了两个参数，分别是在成功时的回调函数和失败时的回调函数；</span>
    <span class="token keyword">new</span> <span class="token class-name">EndWebpackPlugin</span><span class="token punctuation">(</span>
      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// Webpack 构建失败，err 是导致错误的原因</span>
        console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>要实现该插件，需要借助两个事件：</p><ul><li><strong>done</strong>：在成功构建并且输出了文件后，Webpack 即将退出时发生；</li><li><strong>failed</strong>：在构建出现异常导致构建失败，Webpack 即将退出时发生；</li></ul><p>实现该插件非常简单，完整代码如下：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">EndWebpackPlugin</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">doneCallback<span class="token punctuation">,</span> failCallback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 存下在构造函数中传入的回调函数</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>doneCallback <span class="token operator">=</span> doneCallback<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>failCallback <span class="token operator">=</span> failCallback<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">&quot;done&quot;</span><span class="token punctuation">,</span> <span class="token parameter">stats</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 在 done 事件中回调 doneCallback</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doneCallback</span><span class="token punctuation">(</span>stats<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">&quot;failed&quot;</span><span class="token punctuation">,</span> <span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 在 failed 事件中回调 failCallback</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">failCallback</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 导出插件</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> EndWebpackPlugin<span class="token punctuation">;</span>
</code></pre></div><p>从开发这个插件可以看出，找到合适的事件点去完成功能在开发插件时显得尤为重要。 在 <a href="./principle-1">工作原理概括</a> 中详细介绍过 Webpack 在运行过程中广播出常用事件，你可以从中找到你需要的事件。</p></div><div class="page-edit"><!----><!----></div><div class="page-nav"><p class="inner"><span class="prev">
        ← <a href="/webpackLearn/principle/principle-3.html" class="prev">
          编写Loader
        </a></span><span class="next"><a href="/webpackLearn/principle/principle-5.html">
          调试Webpack
        </a> →
      </span></p></div></div></div></div>
    <script src="/webpackLearn/assets/js/app.77d280ee.js" defer></script><script src="/webpackLearn/assets/js/57.82800a68.js" defer></script>
  </body>
</html>
